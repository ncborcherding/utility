---
title: "Integration"
output: html_document
date: "2024-03-20"
---

# Set Up

## Installing scvi-tools


## Loading Libraries and Functions

```{r}
library(BPCells)
library(cluster)
library(reticulate)
library(Seurat)
library(SeuratWrappers)
```

# Integrating All Cells with BPCells and scVI

Now we can take all the Seurat Objects and integrate them. The following code has been optimized for memory efficiency and scalability. It uses `BPCells` to store the count matrices on disk, avoiding the need to load the entire dataset into RAM. It then uses `scVI` for integration, which is more scalable than traditional methods like Harmony or MNN. The raw count matrices are first filtered and subset to a common feature space before being converted to the `BPCells` format.

```{r}
# This chunk uses BPCells to store data on-disk and scVI for integration.

# 1. Setup BPCells directory
# Create a directory to store the on-disk BPCells matrices
bp_dir <- "./data/processedData/bpcells_matrices/"
if (!dir.exists(bp_dir)) {
  dir.create(bp_dir, recursive = TRUE)
}

# 2. Load feature space and file list
files <- list.files("./data/processedData/seuratObjects/")
names <- stringr::str_remove_all(files, ".rds")

# 3. Process objects one-by-one and convert to BPCells format
# This loop reads each Seurat object, applies initial filtering,
# and then writes the count matrix to an on-disk BPCells matrix. 
# This avoids loading all data into RAM at once.
for(x in seq_len(length(names))) {
    
    # Define paths for this sample
    sample_name <- names[x]
    bp_path <- file.path(bp_dir, sample_name)
    meta_path <- file.path(bp_dir, paste0(sample_name, "_meta.rds"))

    # If both the BPCells directory and metadata file exist, skip to the next sample.
    if (dir.exists(bp_path) && file.exists(meta_path)) {
        message(paste("Skipping already processed sample:", sample_name))
        next()
    }
    obj <- readRDS(paste0("./data/processedData/seuratObjects/", files[x]))

    # Apply filtering strategy (no changes here)
    if("predicted.celltype.l1" %in% colnames(obj[[]])) {
      if(any(grepl("CD4 T|CD8 T|other T|NK", obj$predicted.celltype.l1))) {
        obj <- subset(obj, predicted.celltype.l1 %in% c("CD4 T", "CD8 T", "other T", "NK"))
      } else { next() }
    }
    if("CTaa" %in% colnames(obj[[]])) {
        cells <- which(!is.na(obj[[]][,"CTaa"]))
        if(length(cells) == 0) { next() } 
        else { obj <- subset(obj, cells = colnames(obj)[cells]) }
    }
    if("db.class" %in% colnames(obj[[]])) {
        if(ncol(obj) == 0) { next() } 
        else { obj <- subset(obj, db.class == "singlet") }
    }
    if(ncol(obj) <= 1) { next() }
    
    obj$orig.ident <- sample_name

    # Write the BPCells matrix to disk
    BPCells::write_matrix_dir(
        mat = obj@assays$RNA@layers$counts,
        dir = bp_path
    )
    
    # Save the filtered metadata to disk instead of holding it in memory
    saveRDS(obj[[]], file = meta_path)

    # Clean up memory
    rm(obj)
    gc()
}

# 4. Build the list of Seurat objects from disk
processed_names <- list.dirs(bp_dir, full.names = FALSE, recursive = FALSE)

object.list <- lapply(processed_names, function(p_name) {
    bp_path <- file.path(bp_dir, p_name)
    meta_path <- file.path(bp_dir, paste0(p_name, "_meta.rds"))

    # Create the Seurat object from the on-disk components
    Seurat::CreateSeuratObject(
        counts = BPCells::open_matrix_dir(dir = bp_path),
        meta.data = readRDS(meta_path)
    )
})
# Name the list for easy access
names(object.list) <- processed_names


# 5. Identify features to integrate


# 6. Integrate using scVI
object.integrated <- SeuratWrappers::RunScviIntegration(
  object.list,
  assay = "RNA",
  reduction = "scvi",
  scvi_model_path = "./models/scvi/"
)
rm(object.list)
gc()

# 7. Dimensional Reduction
# We can proceed with downstream analysis like PCA and UMAP on the integrated data.
object.integrated <- RunPCA(object.integrated, npcs = 30, verbose = FALSE)
object.integrated <- RunUMAP(object.integrated,
                             reduction = "scvi",
                             dims = 1:30,
                             reduction.name = "umap.scvi")

# Add tissue metadata
object.integrated$tissue <- stringr::str_split(object.integrated$orig.ident, 
                                               "[.]", 
                                               simplify = TRUE)[,2]

# Save the final, memory-efficient, and well-integrated object
saveRDS(object.integrated, "./data/integratedSeuratObject_scVI.rds")

# 8. Visualize the results
# Visualize the UMAP, grouping by different metadata columns to assess integration
DimPlot(
  object.integrated,
  reduction = "umap.scvi",
  group.by = c("orig.ident", "tissue"),
  combine = FALSE, 
  label.size = 2
)

# Visualize expression of key marker genes on the new UMAP
FeaturePlot(object.integrated, 
            features = c("CD4", "CD8A", "FOXP3"), 
            reduction = "umap.scvi")

```

# Leiden Clustering and Evaluation

This section performs cell clustering using the Leiden algorithm, which is a fast and high-quality community detection algorithm. To determine the optimal clustering granularity, we systematically test a range of resolution parameters. The best resolution is selected by finding the one that maximizes the average silhouette width, a measure of cluster cohesion and separation.

```{r}
# 1. Find Neighbors
# This step builds a Shared Nearest Neighbor (SNN) graph, which is required for clustering.
# We use the 'scvi' reduction which represents the integrated data space.
object.integrated <- FindNeighbors(object.integrated, 
                                   reduction = "scvi", 
                                   dims = 1:30)

# 2. Evaluate Clustering Resolutions
# We will test a range of resolutions for the Leiden algorithm to find the one
# that gives the most coherent clusters. We'll use the average silhouette
# width as our metric. A higher silhouette score indicates better-defined clusters.

# Define the range of resolutions to test
resolutions <- seq(0.1, 1.2, by = 0.1)
silhouette_scores <- c()

for (res in resolutions) {
    cat("Testing resolution:", res, "\n")
    # Run Leiden clustering
    object.integrated <- FindClusters(object.integrated, 
                                      resolution = res, 
                                      algorithm.name = "leiden", 
                                      verbose = FALSE)

    # Calculate silhouette score
    # Note: This can be computationally intensive on large datasets.
    # We take a random sample of 5000 cells to make it feasible.
    if (ncol(object.integrated) > 5000) {
      cells_for_sil <- sample(colnames(object.integrated), 5000)
    } else {
      cells_for_sil <- colnames(object.integrated)
    }

    # The silhouette function requires numeric cluster labels and a distance matrix
    sil <- silhouette(
        x = as.numeric(as.character(object.integrated@meta.data[cells_for_sil, "seurat_clusters"])),
        dist = dist(object.integrated@reductions$scvi@cell.embeddings[cells_for_sil, ])
    )

    # We use the summary of the silhouette object to get the average width
    avg_sil_width <- summary(sil)$avg.width
    silhouette_scores <- c(silhouette_scores, avg_sil_width)
}

# Plot the results to find the optimal resolution
plot(resolutions, silhouette_scores, type = "b", pch = 19,
     xlab = "Resolution", ylab = "Average Silhouette Width",
     main = "Leiden Clustering Resolution Optimization")

# 3. Final Clustering
# Choose the resolution that gives the highest silhouette score
optimal_resolution <- resolutions[which.max(silhouette_scores)]
cat("Optimal resolution found:", optimal_resolution, "\n")

# Re-run clustering with the optimal resolution
object.integrated <- FindClusters(object.integrated, resolution = optimal_resolution, algorithm.name = "leiden", verbose = FALSE)
# Rename the final clusters for clarity
object.integrated$leiden_clusters <- object.integrated$seurat_clusters

# 4. Visualize the Final Clustering
DimPlot(object.integrated, reduction = "umap.scvi", group.by = "leiden_clusters", label = TRUE)

# Save the final object with clustering information
saveRDS(object.integrated, "./data/integratedSeuratObject_scVI_clustered.rds")
```
